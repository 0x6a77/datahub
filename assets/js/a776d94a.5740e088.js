(self.webpackChunkdocs_website=self.webpackChunkdocs_website||[]).push([[9175],{4137:function(e,n,t){"use strict";t.d(n,{Zo:function(){return d},kt:function(){return y}});var i=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function p(e,n){if(null==e)return{};var t,i,a=function(e,n){if(null==e)return{};var t,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)t=r[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=i.createContext({}),l=function(e){var n=i.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=l(e.components);return i.createElement(s.Provider,{value:n},e.children)},m={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},c=i.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),c=l(t),y=a,u=c["".concat(s,".").concat(y)]||c[y]||m[y]||r;return t?i.createElement(u,o(o({ref:n},d),{},{components:t})):i.createElement(u,o({ref:n},d))}));function y(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=c;var p={};for(var s in n)hasOwnProperty.call(n,s)&&(p[s]=n[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,o[1]=p;for(var l=2;l<r;l++)o[l]=t[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}c.displayName="MDXCreateElement"},936:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return p},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return d},default:function(){return c}});var i=t(2122),a=t(9756),r=(t(7294),t(4137)),o=["components"],p={title:"SchemaFieldPath Specification (Version 2)",sidebar_label:"SchemaFieldPath Specification (Version 2)",slug:"/advanced/field-path-spec-v2",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/docs/advanced/field-path-spec-v2.md"},s="SchemaFieldPath Specification (Version 2)",l={unversionedId:"docs/advanced/field-path-spec-v2",id:"docs/advanced/field-path-spec-v2",isDocsHomePage:!1,title:"SchemaFieldPath Specification (Version 2)",description:"This document outlines the formal specification for the fieldPath member of",source:"@site/genDocs/docs/advanced/field-path-spec-v2.md",sourceDirName:"docs/advanced",slug:"/advanced/field-path-spec-v2",permalink:"/docs/advanced/field-path-spec-v2",editUrl:"https://github.com/linkedin/datahub/blob/master/docs/advanced/field-path-spec-v2.md",version:"current",frontMatter:{title:"SchemaFieldPath Specification (Version 2)",sidebar_label:"SchemaFieldPath Specification (Version 2)",slug:"/advanced/field-path-spec-v2",custom_edit_url:"https://github.com/linkedin/datahub/blob/master/docs/advanced/field-path-spec-v2.md"}},d=[{value:"Requirements",id:"requirements",children:[]},{value:"Existing Convention(v1)",id:"existing-conventionv1",children:[{value:"Example: Ambiguous field path",id:"example-ambiguous-field-path",children:[]}]},{value:"The FieldPath encoding scheme(v2)",id:"the-fieldpath-encoding-schemev2",children:[{value:"Formal Spec:",id:"formal-spec",children:[]}]},{value:"Examples",id:"examples",children:[{value:"Primitive types",id:"primitive-types",children:[]},{value:"Records",id:"records",children:[]},{value:"Unions",id:"unions",children:[]},{value:"Arrays",id:"arrays",children:[]},{value:"Maps",id:"maps",children:[]},{value:"Mixed Complex Type Examples",id:"mixed-complex-type-examples",children:[]},{value:"Backward-compatibility",id:"backward-compatibility",children:[]}]}],m={toc:d};function c(e){var n=e.components,t=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"schemafieldpath-specification-version-2"},"SchemaFieldPath Specification (Version 2)"),(0,r.kt)("p",null,"This document outlines the formal specification for the fieldPath member of\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/linkedin/datahub/blob/master/metadata-models/src/main/pegasus/com/linkedin/schema/SchemaField.pdl"},"SchemaField"),"\nmodel. This specification (version 2) takes into account the unique requirements of supporting a wide variety of nested\ntypes, unions and optional fields and is a substantial improvement over the current implementation (version 1)."),(0,r.kt)("h2",{id:"requirements"},"Requirements"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldPath")," field is currently used by datahub for not just rendering the schema fields in the UI, but also as a\nprimary identifier of a field in other places such\nas ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/linkedin/datahub/blob/master/metadata-models/src/main/pegasus/com/linkedin/schema/EditableSchemaFieldInfo.pdl#L12"},"EditableSchemaFieldInfo"),",\nusage stats and data profiles. Therefore, it must satisfy the following requirements."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"must be unique across all fields within a schema."),(0,r.kt)("li",{parentName:"ul"},"make schema navigation in the UI more intuitive."),(0,r.kt)("li",{parentName:"ul"},"allow for capturing and editing documentation of intermediate structs/records leading to a filed, and not just fields."),(0,r.kt)("li",{parentName:"ul"},"allow for identifying the type of schema the field is part of, such as a ",(0,r.kt)("inlineCode",{parentName:"li"},"key-schema")," or a ",(0,r.kt)("inlineCode",{parentName:"li"},"value-schema"),"."),(0,r.kt)("li",{parentName:"ul"},"allow for future-evolution")),(0,r.kt)("h2",{id:"existing-conventionv1"},"Existing Convention(v1)"),(0,r.kt)("p",null,"The existing convention is to simply use the field's name as the ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldPath")," for simple fields, and use the ",(0,r.kt)("inlineCode",{parentName:"p"},"dot"),"\ndelimited names for nested fields. This scheme does not satisfy the ",(0,r.kt)("a",{parentName:"p",href:"#requirements"},"requirements")," stated above. The\nfollowing example illustrates where the ",(0,r.kt)("inlineCode",{parentName:"p"},"uniqueness")," requirement is not satisfied."),(0,r.kt)("h3",{id:"example-ambiguous-field-path"},"Example: Ambiguous field path"),(0,r.kt)("p",null,"Consider the following ",(0,r.kt)("inlineCode",{parentName:"p"},"Avro")," schema which is a ",(0,r.kt)("inlineCode",{parentName:"p"},"union")," of two record types ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"B"),", each having a simple field with\nthe same name ",(0,r.kt)("inlineCode",{parentName:"p"},"f")," that is of type ",(0,r.kt)("inlineCode",{parentName:"p"},"string"),". The v1 naming scheme cannot differentiate if a ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldPath=f")," is referring to\nthe record type ",(0,r.kt)("inlineCode",{parentName:"p"},"A")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"B"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'[\n    {\n        "type": "record",\n        "name": "A",\n        "fields": [{ "name": "f", "type": "string" } ]\n    }, {\n        "type": "record",\n        "name": "B",\n        "fields": [{ "name": "f", "type": "string" } ]\n    }\n]\n')),(0,r.kt)("h2",{id:"the-fieldpath-encoding-schemev2"},"The FieldPath encoding scheme(v2)"),(0,r.kt)("p",null,"The syntax for V2 encoding of the ",(0,r.kt)("inlineCode",{parentName:"p"},"fieldPath")," is captured in the following grammar. The ",(0,r.kt)("inlineCode",{parentName:"p"},"FieldPathSpec")," is essentially\nthe type annotated path of the member, with each token along the path representing one level of nested member,\nstarting from the most-enclosing type, leading up to the member. In the case of ",(0,r.kt)("inlineCode",{parentName:"p"},"unions")," that have ",(0,r.kt)("inlineCode",{parentName:"p"},"one-of")," semantics,\nthe corresponding field will be emitted once for each ",(0,r.kt)("inlineCode",{parentName:"p"},"member")," of the union as its ",(0,r.kt)("inlineCode",{parentName:"p"},"type"),"."),(0,r.kt)("h3",{id:"formal-spec"},"Formal Spec:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"<SchemaFieldPath> := <VersionToken>.<PartOfKeySchemaToken>.<FieldPathSpec>  // when part of a key-schema\n                   | <VersionToken>.<FieldPathSpec> // when part of a value schema\n<VersionToken> := [version=<VersionId>] // [version=2.0] for v2\n<PartOfKeySchemaToken> := [key=True]  // when part of a key schema\n<FieldPathSpec> := <PathTokenPrefix>+  // this is the type prefixed path upto the intermediate type or a field.\n<PathTokenPrefix> := <TypePrefixToken> | <FieldToken> // intermeidate type, or a field\n<FieldToken> := <TypePrefixToken>.<name_of_the_field> // type of field + field name\n<TypePrefixToken> := <NestedTypePrefixToken>.<SimpleTypeToken> | <SimpleTypeToken>\n<NestedTypePrefixToken> := [type=<NestedType>]\n<SimpleTypeToken> := [type=<SimpleType>]\n<NestedType> := <name of a struct/record> | union | array | map\n<SimpleType> := int | float | double | string | fixed | enum\n")),(0,r.kt)("p",null,"For the ",(0,r.kt)("a",{parentName:"p",href:"#example-ambiguous-field-path"},"example above"),", this encoding would produce the following 5 unique field paths.\nNotice that there are 3 unique paths corresponding to the ",(0,r.kt)("inlineCode",{parentName:"p"},"union"),", record ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", and record ",(0,r.kt)("inlineCode",{parentName:"p"},"B")," intermediate types, and 2\nunique paths corresponding to the ",(0,r.kt)("inlineCode",{parentName:"p"},"A.f")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"B.f")," fields."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'unique_v2_field_paths = [\n "[version=2.0].[type=union]",\n "[version=2.0].[type=union].[type=A]",\n "[version=2.0].[type=union].[type=A].[type=string].f",\n "[version=2.0].[type=union].[type=B]",\n "[version=2.0].[type=union].[type=B].[type=string].f"\n]\n')),(0,r.kt)("p",null,"NOTE:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"this encoding always ensures uniqueness within a schema since the full type annotation leading to a field is encoded\nin the fieldPath itself."),(0,r.kt)("li",{parentName:"ul"},"field paths that end with an intermediate type allow us to capture details at record/struct level as well, in addition\nto the fields themselves."),(0,r.kt)("li",{parentName:"ul"},"processing a fieldPath, such as from UI, gets simplified simply by walking each token along the path from left-to-right."),(0,r.kt)("li",{parentName:"ul"},"adding PartOfKeySchemaToken allows for identifying if the field is part of key-schema."),(0,r.kt)("li",{parentName:"ul"},"adding VersionToken allows for future evolvability."),(0,r.kt)("li",{parentName:"ul"},"to represent ",(0,r.kt)("inlineCode",{parentName:"li"},"optional")," fields, which sometimes are modeled as ",(0,r.kt)("inlineCode",{parentName:"li"},"unions")," in formats like ",(0,r.kt)("inlineCode",{parentName:"li"},"Avro"),", instead of treating it\nas a ",(0,r.kt)("inlineCode",{parentName:"li"},"union")," member, set the ",(0,r.kt)("inlineCode",{parentName:"li"},"nullable")," member of ",(0,r.kt)("inlineCode",{parentName:"li"},"SchemaField")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"True"),".")),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)("h3",{id:"primitive-types"},"Primitive types"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema = """\n{\n  "type": "string"\n}\n"""\nunique_v2_field_paths = [\n  "[version=2.0].[type=string]"\n]\n')),(0,r.kt)("h3",{id:"records"},"Records"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Simple Record")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema = """\n{\n  "type": "record",\n  "name": "some.event.E",\n  "namespace": "some.event.N",\n  "doc": "this is the event record E"\n  "fields": [\n    {\n      "name": "a",\n      "type": "string",\n      "doc": "this is string field a of E"\n    },\n    {\n      "name": "b",\n      "type": "string",\n      "doc": "this is string field b of E"\n    }\n  ]\n}\n"""\n\nunique_v2_field_paths = [\n    "[version=2.0].[type=E]", # this is the record E itself that we can maintain documentation for!\n    "[version=2.0].[type=E].[type=string].a",\n    "[version=2.0].[type=E].[type=string].b",\n]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Nested Record")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema = """\n{\n    "type": "record",\n    "name": "SimpleNested",\n    "namespace": "com.linkedin",\n    "fields": [{\n        "name": "nestedRcd",\n        "type": {\n            "type": "record",\n            "name": "InnerRcd",\n            "fields": [{\n                "name": "aStringField",\n                 "type": "string"\n            } ]\n        }\n    }]\n}\n"""\n\nunique_v2_field_paths = [\n  "[version=2.0].[key=True].[type=SimpleNested]",\n  "[version=2.0].[key=True].[type=SimpleNested].[type=InnerRcd]",\n  "[version=2.0].[key=True].[type=SimpleNested].[type=InnerRcd].nestedRcd",\n  "[version=2.0].[key=True].[type=SimpleNested].[type=InnerRcd].nestedRcd.[type=string].aStringField",\n]\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Recursive Record")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema = """\n{\n    "type": "record",\n    "name": "Recursive",\n    "namespace": "com.linkedin",\n    "fields": [{\n        "name": "r",\n        "type": {\n            "type": "record",\n            "name": "R",\n            "fields": [\n                { "name" : "anIntegerField", "type" : "int" },\n                { "name": "aRecursiveField", "type": "com.linkedin.R"}\n            ]\n        }\n    }]\n}\n"""\n\nunique_v2_field_paths = [\n  "[version=2.0].[type=Recursive]",\n  "[version=2.0].[type=Recursive].[type=R]",\n  "[version=2.0].[type=Recursive].[type=R].r",\n  "[version=2.0].[type=Recursive].[type=R].r.[type=int].anIntegerField",\n  "[version=2.0].[type=Recursive].[type=R].r.[type=R]",\n  "[version=2.0].[type=Recursive].[type=R].r.[type=R].aRecursiveField"\n]\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema ="""\n{\n    "type": "record",\n    "name": "TreeNode",\n    "fields": [\n        {\n            "name": "value",\n            "type": "long"\n        },\n        {\n            "name": "children",\n            "type": { "type": "array", "items": "TreeNode" }\n        }\n    ]\n}\n"""\nunique_v2_field_paths = [\n "[version=2.0].[type=TreeNode]",\n "[version=2.0].[type=TreeNode].[type=long].value",\n "[version=2.0].[type=TreeNode].[type=array]",\n "[version=2.0].[type=TreeNode].[type=array].[type=TreeNode]",\n "[version=2.0].[type=TreeNode].[type=array].[type=TreeNode].children",\n]\n')),(0,r.kt)("h3",{id:"unions"},"Unions"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema = """\n{\n    "type": "record",\n    "name": "ABUnion",\n    "namespace": "com.linkedin",\n    "fields": [{\n        "name": "a",\n        "type": [{\n            "type": "record",\n            "name": "A",\n            "fields": [{ "name": "f", "type": "string" } ]\n            }, {\n            "type": "record",\n            "name": "B",\n            "fields": [{ "name": "f", "type": "string" } ]\n            }\n        ]\n    }]\n}\n"""\nunique_v2_field_paths: List[str] = [\n    "[version=2.0].[key=True].[type=ABFooUnion]",\n    "[version=2.0].[key=True].[type=ABFooUnion].[type=union]",\n    "[version=2.0].[key=True].[type=ABFooUnion].[type=union].[type=A]",\n    "[version=2.0].[key=True].[type=ABFooUnion].[type=union].[type=A].a",\n    "[version=2.0].[key=True].[type=ABFooUnion].[type=union].[type=A].a.[type=string].f",\n    "[version=2.0].[key=True].[type=ABFooUnion].[type=union].[type=B]",\n    "[version=2.0].[key=True].[type=ABFooUnion].[type=union].[type=B].a",\n    "[version=2.0].[key=True].[type=ABFooUnion].[type=union].[type=B].a.[type=string].f",\n]\n')),(0,r.kt)("h3",{id:"arrays"},"Arrays"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema = """\n{\n    "type": "record",\n    "name": "NestedArray",\n    "namespace": "com.linkedin",\n    "fields": [{\n        "name": "ar",\n        "type": {\n            "type": "array",\n            "items": {\n                "type": "array",\n                "items": [\n                    "null",\n                    {\n                        "type": "record",\n                        "name": "Foo",\n                        "fields": [ {\n                            "name": "a",\n                            "type": "long"\n                        } ]\n                    }\n                ]\n            }\n        }\n    }]\n}\n"""\nunique_v2_field_paths: List[str] = [\n  "[version=2.0].[type=NestedArray]",\n  "[version=2.0].[type=NestedArray].[type=array]",\n  "[version=2.0].[type=NestedArray].[type=array].[type=array]",\n  "[version=2.0].[type=NestedArray].[type=array].[type=array].[type=Foo]",\n  "[version=2.0].[type=NestedArray].[type=array].[type=array].[type=Foo].ar",\n  "[version=2.0].[type=NestedArray].[type=array].[type=array].[type=Foo].ar.[type=long].a",\n]\n')),(0,r.kt)("h3",{id:"maps"},"Maps"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'avro_schema = """\n{\n  "type": "record",\n  "name": "R",\n  "namespace": "some.namespace",\n  "fields": [\n    {\n      "name": "a_map_of_longs_field",\n      "type": {\n        "type": "map",\n        "values": "long"\n      }\n    }\n  ]\n}\n"""\nunique_v2_field_paths = [\n  "[version=2.0].[type=R]",\n  "[version=2.0].[type=R].[type=map]",\n  "[version=2.0].[type=R].[type=map].[type=long].a_map_of_longs_field",\n]\n\n\n')),(0,r.kt)("h3",{id:"mixed-complex-type-examples"},"Mixed Complex Type Examples"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'# Combines arrays, unions and records.\navro_schema = """\n{\n    "type": "record",\n    "name": "ABFooUnion",\n    "namespace": "com.linkedin",\n    "fields": [{\n        "name": "a",\n        "type": [ {\n            "type": "record",\n            "name": "A",\n            "fields": [{ "name": "f", "type": "string" } ]\n            }, {\n            "type": "record",\n            "name": "B",\n            "fields": [{ "name": "f", "type": "string" } ]\n            }, {\n            "type": "array",\n            "items": {\n                "type": "array",\n                "items": [\n                    "null",\n                    {\n                        "type": "record",\n                        "name": "Foo",\n                        "fields": [{ "name": "f", "type": "long" }]\n                    }\n                ]\n            }\n    }]\n    }]\n}\n"""\n\nunique_v2_field_paths: List[str] = [\n  "[version=2.0].[type=ABFooUnion]",\n  "[version=2.0].[type=ABFooUnion].[type=union]",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=A]",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=A].a",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=A].a.[type=string].f",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=B]",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=B].a",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=B].a.[type=string].f",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=array]",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=array].[type=array]",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=array].[type=array].[type=Foo]",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=array].[type=array].[type=Foo].a",\n  "[version=2.0].[type=ABFooUnion].[type=union].[type=array].[type=array].[type=Foo].a.[type=long].f",\n]\n')),(0,r.kt)("p",null,"For more examples, see\nthe ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/linkedin/datahub/blob/master/metadata-ingestion/tests/unit/test_schema_util.py"},"unit-tests for AvroToMceSchemaConverter"),"\n."),(0,r.kt)("h3",{id:"backward-compatibility"},"Backward-compatibility"),(0,r.kt)("p",null,"While this format is not directly compatible with the v1 format, the v1 equivalent can easily be constructed from the v2\nencoding by stripping away all the v2 tokens enclosed in the square-brackets ",(0,r.kt)("inlineCode",{parentName:"p"},"[<new_in_v2>]"),"."))}c.isMDXComponent=!0}}]);